<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anniversary Video Voting Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        /* General styling for the entire page */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per instructions */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* Gradient background */
            min-height: 100vh;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05); /* Slightly transparent background for the container */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(15px); /* Stronger blur effect */
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1, h2, h3 {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 2em;
        }

        h3 {
            font-size: 1.5em;
        }

        /* Connection status indicator */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            z-index: 1000;
            border: 2px solid transparent;
        }

        .connection-status.connected {
            border-color: #4CAF50; /* Green border for connected */
        }

        .connection-status.disconnected {
            border-color: #FF6B6B; /* Red border for disconnected */
        }

        /* Mode selector buttons (Main/Phone) */
        .mode-selector {
            text-align: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px 30px;
            margin: 0 10px;
            border-radius: 25px; /* Rounded corners */
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .mode-btn:hover, .mode-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        /* Main Screen Styles */
        .main-screen {
            display: none;
            width: 100%;
        }

        .main-screen.active {
            display: block;
        }

        .video-section, .results-section, .live-votes, .voting-area, .video-playlist {
            background: rgba(255, 255, 255, 0.1); /* Lighter transparent background */
            border-radius: 20px; /* Rounded corners */
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        .upload-area {
            border: 3px dashed rgba(255, 255, 255, 0.5); /* Dashed border */
            border-radius: 15px; /* Rounded corners */
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049); /* Green gradient */
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px; /* Rounded corners */
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .video-playlist {
            padding: 20px;
            margin-bottom: 20px;
        }

        .playlist-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .playlist-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px; /* Rounded corners */
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .playlist-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .playlist-item.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .playlist-item .video-name {
            font-weight: bold;
            margin-bottom: 5px;
            word-break: break-word;
        }

        .playlist-item .video-size {
            font-size: 12px;
            opacity: 0.7;
        }

        .video-display {
            text-align: center;
            margin-bottom: 20px;
        }

        video {
            max-width: 100%;
            max-height: 60vh;
            width: 100%; /* Ensure video takes full width of its container */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #000; /* Black background for video player */
        }

        .video-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        #videoCounter {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 15px; /* Rounded corners */
            font-weight: bold;
        }

        .countdown-display {
            font-size: 72px;
            font-weight: bold;
            text-align: center;
            margin: 30px 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: pulse 1s infinite alternate; /* Smooth pulse animation */
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        .results-section {
            margin-top: 30px;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
            min-height: 300px; /* Ensure chart has enough height */
        }

        .control-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .control-btn {
            background: linear-gradient(45deg, #FF6B6B, #FF5252); /* Red gradient */
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 25px; /* Rounded corners */
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .control-btn.start {
            background: linear-gradient(45deg, #4CAF50, #45a049); /* Green gradient for start */
        }

        .control-btn.reset {
            background: linear-gradient(45deg, #FFA726, #FF9800); /* Orange gradient for reset */
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Phone Screen Styles */
        .phone-screen {
            display: none;
            text-align: center;
            padding: 20px;
            width: 100%;
        }

        .phone-screen.active {
            display: block;
        }

        .voting-area {
            margin-top: 50px;
            padding: 40px 20px;
        }

        .vote-countdown {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .vote-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .vote-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 20px 30px;
            border-radius: 20px; /* Rounded corners */
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .vote-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .vote-btn.cry {
            border-color: #4CAF50; /* Green for Cry */
        }

        .vote-btn.cry:hover, .vote-btn.cry.selected {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .vote-btn.roll-eyes {
            border-color: #FF6B6B; /* Red for Roll Eyes */
        }

        .vote-btn.roll-eyes:hover, .vote-btn.roll-eyes.selected {
            background: rgba(255, 107, 107, 0.3);
            border-color: #FF6B6B;
        }

        .vote-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .waiting-message {
            font-size: 24px;
            margin-top: 30px;
            opacity: 0.8;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            font-size: 18px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px; /* Rounded corners */
            backdrop-filter: blur(10px);
            text-align: center;
            margin: 10px; /* Spacing between items */
            flex-grow: 1;
            min-width: 150px; /* Minimum width for stats on smaller screens */
        }

        .emoji {
            font-size: 1.8em; /* Larger emoji for impact */
            display: block; /* Ensure emoji is on its own line */
            margin-bottom: 5px;
        }

        .live-votes {
            padding: 20px;
            margin-top: 20px;
        }

        .live-votes h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        .live-vote-counts {
            display: flex;
            justify-content: space-around;
            font-size: 18px;
            flex-wrap: wrap;
        }

        .live-count {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px; /* Rounded corners */
            text-align: center;
            margin: 5px;
            flex-grow: 1;
            min-width: 100px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .mode-btn {
                padding: 10px 20px;
                font-size: 16px;
                margin: 0 5px;
            }
            .video-section, .results-section, .voting-area {
                padding: 20px;
            }
            .countdown-display {
                font-size: 48px;
            }
            .vote-countdown {
                font-size: 36px;
            }
            .vote-btn {
                padding: 15px 20px;
                font-size: 18px;
                min-width: 100px;
            }
            .playlist-items {
                grid-template-columns: 1fr; /* Single column on small screens */
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        üîÑ Connecting...
    </div>

    <div class="container">
        <h1>üéâ Anniversary Video Voting Game üéâ</h1>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="switchMode('main')">üì∫ Main Screen (Projector)</button>
            <button class="mode-btn" onclick="switchMode('phone')">üì± Phone (Voting)</button>
        </div>

        <!-- Main Screen View - For the projector -->
        <div class="main-screen active" id="mainScreen">
            <div class="video-section">
                <h2>Video Upload & Display</h2>
                <div class="upload-area" id="uploadArea">
                    <p>üìÅ Drop video files here or click to upload multiple videos</p>
                    <input type="file" id="fileInput" class="file-input" accept="video/*, .avi" multiple>
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Choose Videos</button>
                </div>

                <div class="video-playlist" id="videoPlaylist" style="display: none;">
                    <h3>Video Playlist</h3>
                    <div class="playlist-items" id="playlistItems"></div>
                </div>

                <div class="video-display" id="videoDisplay" style="display: none;">
                    <video id="videoPlayer" controls muted preload="metadata"></video>
                    <div class="video-controls">
                        <button class="control-btn" onclick="previousVideo()">‚èÆÔ∏è Previous</button>
                        <button class="control-btn" onclick="nextVideo()">‚è≠Ô∏è Next</button>
                        <span id="videoCounter">Video 1 of 1</span>
                    </div>
                </div>

                <div class="control-panel">
                    <button class="control-btn start" id="startBtn" onclick="startVoting()">üé¨ Start Voting</button>
                    <button class="control-btn reset" onclick="resetVoting()">üîÑ Reset Votes</button>
                    <button class="control-btn" onclick="clearVideos()">üóëÔ∏è Clear Videos</button>
                </div>

                <div class="live-votes" id="liveVotes" style="display: none;">
                    <h3>Live Vote Count</h3>
                    <div class="live-vote-counts">
                        <div class="live-count">
                            <div class="emoji">üò¢</div>
                            <div>Cry: <span id="liveCryCount">0</span></div>
                        </div>
                        <div class="live-count">
                            <div class="emoji">üôÑ</div>
                            <div>Roll Eyes: <span id="liveRollCount">0</span></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="countdown-display" id="countdownDisplay" style="display: none;">
                Ready to vote!
            </div>

            <div class="results-section" id="resultsSection" style="display: none;">
                <h2>üìä Voting Results</h2>
                <div class="chart-container">
                    <canvas id="resultsChart"></canvas>
                </div>
                <div class="stats" id="statsDisplay"></div>
            </div>
        </div>

        <!-- Phone Screen View - For participants' phones -->
        <div class="phone-screen" id="phoneScreen">
            <div class="voting-area">
                <h2>Cast Your Vote!</h2>
                <div class="vote-countdown" id="phoneCountdown">Waiting for voting to start...</div>

                <div class="vote-buttons" id="voteButtons" style="display: none;">
                    <button class="vote-btn cry" onclick="castVote('cry')">
                        üò¢<br>Cry
                    </button>
                    <button class="vote-btn roll-eyes" onclick="castVote('roll-eyes')">
                        üôÑ<br>Roll Eyes
                    </button>
                </div>

                <div class="waiting-message" id="waitingMessage">
                    Waiting for the host to start voting...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state managed locally and synchronized via localStorage events
        let gameState = {
            voting: false,
            countdown: 7, // Initial countdown time
            votes: { cry: 0, rollEyes: 0 },
            voters: new Set(), // To keep track of voters for the current round
            chart: null, // Chart.js instance
            videos: [], // Array to store video objects (name, size, URL)
            currentVideoIndex: 0,
            sessionId: generateSessionId() // Unique ID for this browser session
        };

        let countdownTimer; // Timer for the voting countdown

        /**
         * Generates a unique session ID for cross-device synchronization.
         * @returns {string} A unique session ID.
         */
        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        /**
         * Broadcasts the current game state to other tabs/devices using localStorage.
         * This enables rudimentary cross-device synchronization without a backend.
         */
        function broadcastGameState() {
            const syncData = {
                timestamp: Date.now(),
                sessionId: gameState.sessionId,
                voting: gameState.voting,
                countdown: gameState.countdown,
                votes: gameState.votes,
                action: 'sync'
            };
            localStorage.setItem('gameSync', JSON.stringify(syncData));
        }

        /**
         * Listens for localStorage 'gameSync' events from other tabs/devices.
         * This is how the phone screen will receive updates from the main screen.
         */
        window.addEventListener('storage', function(e) {
            if (e.key === 'gameSync' && e.newValue) {
                try {
                    const syncData = JSON.parse(e.newValue);
                    // Only process sync data if it's from a different session (device/tab)
                    // and if the timestamp indicates it's a newer or relevant update.
                    // This prevents infinite loops and ensures the latest state is applied.
                    if (syncData.sessionId !== gameState.sessionId && syncData.timestamp > (gameState.lastSyncTimestamp || 0)) {
                        handleSyncEvent(syncData);
                        gameState.lastSyncTimestamp = syncData.timestamp; // Update last sync time
                    }
                } catch (error) {
                    console.error('Error parsing sync data from localStorage:', error);
                }
            }
        });

        /**
         * Handles incoming synchronization events from other devices.
         * Updates the local game state and UI accordingly.
         * @param {object} syncData - The game state object received from localStorage.
         */
        function handleSyncEvent(syncData) {
            const wasVoting = gameState.voting; // Store previous voting state

            // Update local game state from synced data
            gameState.voting = syncData.voting;
            gameState.countdown = syncData.countdown;
            gameState.votes = syncData.votes;

            // Update UI based on the synchronized state
            if (syncData.voting && !wasVoting) {
                // Voting just started on the main screen, update phone UI
                startVotingUI();
                startCountdownSync(syncData.countdown); // Start countdown sync on phone
            } else if (!syncData.voting && wasVoting) {
                // Voting just ended on the main screen, update phone UI
                endVotingUI();
            }

            // Always update live counts and phone countdown for real-time feedback
            updateLiveVotes();
            updatePhoneCountdown();
        }

        /**
         * Updates the connection status indicator.
         * (Note: This is a placeholder for visual feedback. True "connection" requires a backend).
         * @param {boolean} connected - True if connected, false if disconnected.
         */
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'üü¢ Connected';
                status.className = 'connection-status connected';
            } else {
                status.textContent = 'üî¥ Offline';
                status.className = 'connection-status disconnected';
            }
        }

        // Initialize connection status visually (assuming local connection is always "connected")
        updateConnectionStatus(true);

        /**
         * Switches between 'main' (projector) and 'phone' (voting) modes.
         * Updates button styles and screen visibility.
         * @param {string} mode - 'main' or 'phone'.
         */
        function switchMode(mode) {
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.main-screen, .phone-screen').forEach(screen => screen.classList.remove('active'));

            if (mode === 'main') {
                document.querySelector('.mode-btn:first-child').classList.add('active');
                document.getElementById('mainScreen').classList.add('active');
            } else {
                document.querySelector('.mode-btn:last-child').classList.add('active');
                document.getElementById('phoneScreen').classList.add('active');
            }
        }

        // --- Video Upload & Playback Functions (Main Screen Only) ---

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const videoDisplay = document.getElementById('videoDisplay');
        const videoPlayer = document.getElementById('videoPlayer');

        // Drag and drop event listeners for video upload area
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            // Filter for video files OR .avi extension
            const files = Array.from(e.dataTransfer.files).filter(file => 
                file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.avi')
            );
            if (files.length > 0) {
                loadVideos(files);
            }
        });

        // Click event listener for file input (hidden)
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            // Filter for video files OR .avi extension
            const filteredFiles = files.filter(file => 
                file.type.startsWith('video/') || file.name.toLowerCase().endsWith('.avi')
            );
            if (filteredFiles.length > 0) {
                loadVideos(filteredFiles);
            }
        });

        /**
         * Loads video files into the playlist and sets up the first video for playback.
         * @param {File[]} files - An array of video File objects.
         */
        function loadVideos(files) {
            // Revoke old object URLs to free up memory
            gameState.videos.forEach(video => {
                if (video.url) {
                    URL.revokeObjectURL(video.url);
                }
            });

            gameState.videos = [];
            const playlistItemsContainer = document.getElementById('playlistItems');
            playlistItemsContainer.innerHTML = ''; // Clear existing playlist items

            files.forEach((file, index) => {
                const videoData = {
                    name: file.name,
                    size: formatFileSize(file.size),
                    url: URL.createObjectURL(file) // Create a Blob URL for the video
                };
                gameState.videos.push(videoData);

                // Create playlist item element
                const item = document.createElement('div');
                item.className = 'playlist-item rounded-xl'; // Apply rounded-xl from Tailwind concept
                item.innerHTML = `
                    <div class="video-name">${videoData.name}</div>
                    <div class="video-size">${videoData.size}</div>
                `;
                item.onclick = () => selectVideo(index);
                playlistItemsContainer.appendChild(item);
            });

            document.getElementById('videoPlaylist').style.display = 'block';
            uploadArea.style.display = 'none';

            // Automatically select and load the first video if available
            if (gameState.videos.length > 0) {
                selectVideo(0);
            }
        }

        /**
         * Selects and loads a video from the playlist into the video player.
         * @param {number} index - The index of the video in the `gameState.videos` array.
         */
        function selectVideo(index) {
            // Ensure index is within bounds
            if (index < 0 || index >= gameState.videos.length) {
                console.warn('Invalid video index selected:', index);
                return;
            }

            gameState.currentVideoIndex = index;
            const video = gameState.videos[index];

            // Update playlist item active state visually
            document.querySelectorAll('.playlist-item').forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });

            // Clean up previous video URL to prevent memory leaks
            if (videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(videoPlayer.src);
            }

            videoPlayer.src = video.url;
            videoPlayer.load(); // Load the new video

            // Remove any existing error messages before attempting to play a new video
            const existingError = videoDisplay.querySelector('.video-error-message');
            if (existingError) {
                existingError.remove();
            }

            // Event listener for video loading errors
            videoPlayer.onerror = function(e) {
                console.error('Video loading event error:', e); // Log the event object
                let errorMessage = 'The browser could not play this video. This often happens with unsupported video codecs.';
                // Provide more specific details if the MediaError object has them
                if (videoPlayer.error) {
                    console.error('MediaError object:', videoPlayer.error); // Log the MediaError object
                    switch (videoPlayer.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED:
                            errorMessage = 'Video loading aborted by user.';
                            break;
                        case MediaError.MEDIA_ERR_NETWORK:
                            errorMessage = 'Network error: Video download failed.';
                            break;
                        case MediaError.MEDIA_ERR_DECODE:
                            errorMessage = 'Video decoding error: Corrupted or unsupported media.';
                            break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMessage = 'Video format not supported by your browser.';
                            break;
                        default:
                            errorMessage = `An unexpected video error occurred (Code: ${videoPlayer.error.code || 'N/A'}).`;
                            break;
                    }
                    if (videoPlayer.error.message) {
                        errorMessage += ` Details: ${videoPlayer.error.message}`;
                    }
                } else {
                    // Fallback for cases where videoPlayer.error is null or empty,
                    // but an error event still fired. This suggests a very general playback failure.
                    errorMessage = 'The video could not be played. This might be due to an unsupported video format or codec, or a general playback issue.';
                }

                // Display the error message to the user
                const errorElement = document.createElement('p');
                errorElement.style.color = 'red';
                errorElement.style.marginTop = '10px';
                errorElement.textContent = `Error playing video: ${errorMessage} Please try a different file.`;
                errorElement.classList.add('video-error-message'); // Add a class to identify it
                videoDisplay.appendChild(errorElement); // Append to videoDisplay container
            };

            document.getElementById('videoDisplay').style.display = 'block';
            document.getElementById('videoCounter').textContent = `Video ${index + 1} of ${gameState.videos.length}`;
        }

        /**
         * Plays the previous video in the playlist, if available.
         */
        function previousVideo() {
            if (gameState.currentVideoIndex > 0) {
                selectVideo(gameState.currentVideoIndex - 1);
            }
        }

        /**
         * Plays the next video in the playlist, if available.
         */
        function nextVideo() {
            if (gameState.currentVideoIndex < gameState.videos.length - 1) {
                selectVideo(gameState.currentVideoIndex + 1);
            }
        }

        /**
         * Formats file size into a human-readable string (e.g., KB, MB, GB).
         * @param {number} bytes - The size in bytes.
         * @returns {string} Formatted file size.
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /**
         * Clears all uploaded videos and resets the video player and UI.
         */
        function clearVideos() { // Renamed from clearVideo to clearVideos for clarity
            // Revoke all object URLs to prevent memory leaks
            gameState.videos.forEach(video => {
                if (video.url) {
                    URL.revokeObjectURL(video.url);
                }
            });

            gameState.videos = [];
            gameState.currentVideoIndex = 0;

            // Reset video player
            videoPlayer.src = '';
            videoPlayer.load(); // Important to clear the video source

            // Hide video display and playlist, show upload area
            videoDisplay.style.display = 'none';
            document.getElementById('videoPlaylist').style.display = 'none';
            uploadArea.style.display = 'block';
            fileInput.value = ''; // Clear the file input for re-uploading

            // Clear playlist items
            document.getElementById('playlistItems').innerHTML = '';

            // Remove any existing error messages
            const existingError = videoDisplay.querySelector('.video-error-message');
            if (existingError) {
                existingError.remove();
            }

            // Reset voting state as well
            resetVoting();
        }

        // --- Voting Logic (Main & Phone Screens) ---

        /**
         * Initiates the voting process.
         * This function is primarily called from the main screen.
         */
        function startVoting() {
            if (gameState.voting) return; // Prevent starting if already voting

            // Reset votes and voters for the new round
            gameState.voting = true;
            gameState.countdown = 7;
            gameState.votes = { cry: 0, rollEyes: 0 };
            gameState.voters.clear(); // Clear voters from previous round

            startVotingUI(); // Update UI for voting state
            broadcastGameState(); // Inform other devices that voting has started

            // Start countdown timer
            countdownTimer = setInterval(() => {
                gameState.countdown--;
                updateCountdownDisplay(); // Update countdown display on both screens
                broadcastGameState(); // Broadcast countdown changes

                if (gameState.countdown < 0) {
                    clearInterval(countdownTimer); // Stop countdown
                    endVoting(); // End voting when countdown finishes
                }
            }, 1000);
        }

        /**
         * Updates the UI elements when voting starts (on both main and phone screens).
         */
        function startVotingUI() {
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('countdownDisplay').style.display = 'block';
            document.getElementById('liveVotes').style.display = 'block';
            document.getElementById('startBtn').disabled = true; // Disable start button while voting

            // Phone UI updates
            document.getElementById('voteButtons').style.display = 'flex';
            document.getElementById('waitingMessage').style.display = 'none';
            document.querySelectorAll('.vote-btn').forEach(btn => {
                btn.disabled = false; // Enable vote buttons
                btn.classList.remove('selected'); // Remove selected state from previous vote
            });

            updateCountdownDisplay();
            updateLiveVotes();
        }

        /**
         * Synchronizes the countdown display on the phone screen.
         * @param {number} initialCountdown - The countdown value to sync to.
         */
        function startCountdownSync(initialCountdown) {
            gameState.countdown = initialCountdown;
            updateCountdownDisplay();
        }
        

        /**
         * Updates the text content of the countdown displays on both screens.
         */
        function updateCountdownDisplay() {
            const mainCountdown = document.getElementById('countdownDisplay');
            const phoneCountdown = document.getElementById('phoneCountdown');

            if (gameState.countdown >= 0) {
                mainCountdown.textContent = gameState.countdown;
                phoneCountdown.textContent = gameState.countdown;
            } else {
                mainCountdown.textContent = 'Voting Ended!';
                phoneCountdown.textContent = 'Voting Ended!';
            }
        }

        /**
         * Updates the live vote counts displayed on the main screen.
         */
        function updateLiveVotes() {
            document.getElementById('liveCryCount').textContent = gameState.votes.cry;
            document.getElementById('liveRollCount').textContent = gameState.votes.rollEyes;
        }

        /**
         * Updates the countdown message on the phone screen.
         */
        function updatePhoneCountdown() {
            // This function is mainly called for real-time updates from broadcastGameState
            // The `updateCountdownDisplay` handles the core countdown logic.
            // This ensures messages like "Waiting for voting to start..." are correct.
            const phoneCountdownElement = document.getElementById('phoneCountdown');
            if (!gameState.voting) {
                if (phoneCountdownElement.textContent !== 'Results on main screen!') { // Keep results message if already shown
                    phoneCountdownElement.textContent = 'Waiting for voting to start...';
                }
            }
        }

        /**
         * Casts a vote from a participant's phone.
         * @param {string} vote - 'cry' or 'roll-eyes'.
         */
        function castVote(vote) {
            // Persistent voter ID per device/tab
            if (!localStorage.getItem('voterId')) {
                localStorage.setItem('voterId', 'voter_' + Math.random().toString(36).substr(2, 9));
            }
            const voterId = localStorage.getItem('voterId');

            if (!gameState.voting || gameState.voters.has(voterId)) {
                // If voting is not active or this voter has already voted in this round, do nothing.
                return;
            }

            gameState.voters.add(voterId); // Mark this voter as having voted

            if (vote === 'cry') {
                gameState.votes.cry++;
            } else if (vote === 'roll-eyes') {
                gameState.votes.rollEyes++;
            }

            // Visual feedback on the phone for the cast vote
            document.querySelectorAll('.vote-btn').forEach(btn => {
                btn.disabled = true; // Disable all buttons after a vote
                btn.classList.remove('selected');
            });
            document.querySelector(`.vote-btn.${vote}`).classList.add('selected'); // Highlight selected button

            document.getElementById('phoneCountdown').textContent = 'Vote Cast! ‚úì';

            // Broadcast the updated vote counts to the main screen and other phones
            broadcastGameState();
            updateLiveVotes(); // Update live counts on current phone (if this is the main screen)
        }

        /**
         * Ends the voting round.
         * Primarily called from the main screen when countdown finishes or reset is pressed.
         */
        function endVoting() {
            gameState.voting = false;
            clearInterval(countdownTimer); // Ensure timer is cleared
            broadcastGameState(); // Broadcast that voting has ended
            endVotingUI(); // Update UI for end of voting state
        }

        /**
         * Updates the UI elements when voting ends (on both main and phone screens).
         */
        function endVotingUI() {
            document.getElementById('countdownDisplay').style.display = 'none';
            document.getElementById('liveVotes').style.display = 'none';
            document.getElementById('startBtn').disabled = false; // Enable start button again

            // Phone UI updates
            document.getElementById('voteButtons').style.display = 'none';
            document.getElementById('waitingMessage').style.display = 'block';
            document.getElementById('waitingMessage').textContent = 'Voting ended! Check the main screen for results.';
            document.getElementById('phoneCountdown').textContent = 'Results on main screen!';

            showResults(); // Display results chart on the main screen
        }

        /**
         * Resets all voting data and UI to initial state.
         * Primarily called from the main screen.
         */
        function resetVoting() {
            clearInterval(countdownTimer); // Stop any active countdown
            gameState.voting = false;
            gameState.countdown = 7;
            gameState.votes = { cry: 0, rollEyes: 0 };
            gameState.voters.clear();

            // Reset main screen UI
            document.getElementById('countdownDisplay').style.display = 'none';
            document.getElementById('liveVotes').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('startBtn').disabled = false;
            updateLiveVotes(); // Reset live counts to 0

            // Reset phone screen UI
            document.getElementById('voteButtons').style.display = 'none';
            document.getElementById('waitingMessage').style.display = 'block';
            document.getElementById('waitingMessage').textContent = 'Waiting for the host to start voting...';
            document.getElementById('phoneCountdown').textContent = 'Waiting for voting to start...';
            document.querySelectorAll('.vote-btn').forEach(btn => {
                btn.disabled = false;
                btn.classList.remove('selected');
            });

            if (gameState.chart) {
                gameState.chart.destroy(); // Destroy previous chart instance
                gameState.chart = null;
            }
            document.getElementById('statsDisplay').innerHTML = ''; // Clear stats display

            broadcastGameState(); // Broadcast reset state
        }

        /**
         * Displays the voting results using a Chart.js pie chart and numerical statistics.
         * This is called on the main screen after voting ends.
         */
        function showResults() {
            document.getElementById('resultsSection').style.display = 'block';
            const total = gameState.votes.cry + gameState.votes.rollEyes;

            // Handle case with no votes
            if (total === 0) {
                document.getElementById('statsDisplay').innerHTML = '<div class="stat-item">No votes cast for this video!</div>';
                if (gameState.chart) {
                    gameState.chart.destroy(); // Destroy existing chart if no votes
                    gameState.chart = null;
                }
                return;
            }

            const cryPercent = Math.round((gameState.votes.cry / total) * 100);
            const rollEyesPercent = Math.round((gameState.votes.rollEyes / total) * 100);

            // Update numerical stats display
            document.getElementById('statsDisplay').innerHTML = `
                <div class="stat-item rounded-lg">
                    <span class="emoji">üò¢</span><br>
                    Cry: ${gameState.votes.cry} (${cryPercent}%)
                </div>
                <div class="stat-item rounded-lg">
                    <span class="emoji">üôÑ</span><br>
                    Roll Eyes: ${gameState.votes.rollEyes} (${rollEyesPercent}%)
                </div>
                <div class="stat-item rounded-lg">
                    <span class="emoji">üë•</span><br>
                    Total Votes: ${total}
                </div>
            `;

            // Create or update the Chart.js pie chart
            const ctx = document.getElementById('resultsChart').getContext('2d');

            // Destroy existing chart instance before creating a new one
            if (gameState.chart) {
                gameState.chart.destroy();
            }

            gameState.chart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: ['üò¢ Cry', 'üôÑ Roll Eyes'],
                    datasets: [{
                        data: [gameState.votes.cry, gameState.votes.rollEyes],
                        backgroundColor: [
                            'rgba(76, 175, 80, 0.8)', // Green for Cry
                            'rgba(255, 107, 107, 0.8)' // Red for Roll Eyes
                        ],
                        borderColor: [
                            'rgba(76, 175, 80, 1)',
                            'rgba(255, 107, 107, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allow chart to fill container
                    plugins: {
                        legend: {
                            labels: {
                                color: 'white', // White text for legend
                                font: {
                                    size: 16
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed !== null) {
                                        label += context.parsed + ' votes (' + context.dataset.data[context.dataIndex] / total * 100 + '%)';
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initial setup when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial mode to main screen
            switchMode('main');
            // Ensure phone countdown is correct on load
            updatePhoneCountdown();
        });
    </script>
</body>
</html>
